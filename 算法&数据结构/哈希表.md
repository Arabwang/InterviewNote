哈希表
---

    利用 Hash Table 可以快速查找一个元素是否存在等问题，但是需要一定的空间来存储。在优先考虑时间复杂度的情况下，可以利用 Hash Table 这种空间换取时间的做法。
    Java 中的 HashSet 用于存储一个集合，并以 O(1) 的时间复杂度查找元素 是否在
集合中。
    如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在，例如对于只有小写字符的元素，就可以用一个长度为26的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。

数组中的两个数和为给定值
1. Two Sum (Easy)

    可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(NlogN)，空间复杂度为 O(1)。
    用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(N)，空间复杂度为 O(N)，使用空间来换取时间。

    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (map.containsKey(target - nums[i])) return new int[] { map.get(target - nums[i]), i };
            else map.put(nums[i], i);
        }
        return null;
    }

判断数组是否含有相同元素
217. Contains Duplicate (Easy)

    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int num : nums) {
            set.add(num);
        }
        return set.size() < nums.length;
    }

最长和谐序列
594. Longest Harmonious Subsequence (Easy)

Input: [1,3,2,2,5,2,3,7]
Output: 5
Explanation: The longest harmonious subsequence is [3,2,2,2,3].
和谐序列中最大数和最小数只差正好为 1。

    public int findLHS(int[] nums) {
        Map<Long, Integer> map = new HashMap<>();
        for (long num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        int result = 0;
        for (long key : map.keySet()) {
            if (map.containsKey(key + 1)) {
                result = Math.max(result, map.get(key + 1) + map.get(key));
            }
        }
        return result;
    }

最长连续序列
128. Longest Consecutive Sequence (Hard)

Given [100, 4, 200, 1, 3, 2],
The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
题目要求：以 O(N) 的时间复杂度求解。

    public int longestConsecutive(int[] nums) {
        Map<Integer, Integer> numCnts = new HashMap<>();
        for (int num : nums) {
            numCnts.put(num, 1);
        }
        for (int num : nums) {
            count(numCnts, num);
        }
        int max = 0;
        for (int num : nums) {
            max = Math.max(max, numCnts.get(num));
        }
        return max;
    }
    
    private int count(Map<Integer, Integer> numCnts, int num) {
        if (!numCnts.containsKey(num)) {
            return 0;
        }
        int cnt = numCnts.get(num);
        if (cnt > 1) {
            return cnt;
        }
        cnt = count(numCnts, num + 1) + 1;
        numCnts.put(num, cnt);
        return cnt;
    }


tags:数据结构

