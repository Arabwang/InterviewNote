# 栈和队列

# 栈

源码：

```
public class Stack<E> extends Vector<E> {
     
    /** use serialVersionUID from JDK 1.0.2 for interoperability */
    private static final long serialVersionUID = 1224463164541339165L;
    
    public Stack() {
    }
 
    public E push(E item) {
        addElement(item);
 
        return item;
    }
 
    public synchronized E pop() {
        E	obj;
        int	len = size();
 
        obj = peek();
        removeElementAt(len - 1);
 
        return obj;
    }
 
    public synchronized E peek() {
        int	len = size();
 
        if (len == 0)
            throw new EmptyStackException();
        return elementAt(len - 1);
    }
 
    public boolean empty() {
        return size() == 0;
    }
 
    public synchronized int search(Object o) {
        int i = lastIndexOf(o);
 
        if (i >= 0) {
            return size() - i;
        }
        return -1;
    }
}
```

# 队列

下面是队列的链表实现，需要维护 first 和 last 节点指针，分别指向队首和队尾。

这里需要考虑 first 和 last 指针哪个作为链表的开头。因为出队列操作需要让队首元素的下一个元素成为队首，所以需要容易获取下一个元素，而链表的头部节点的 next 指针指向下一个元素，因此可以让 first 指针链表的开头。

```
public interface MyQueue<Item> extends Iterable<Item> {

    int size();
    boolean isEmpty();
    MyQueue<Item> add(Item item);
    Item remove() throws Exception;
}

public class ListQueue<Item> implements MyQueue<Item> {

    private Node first;
    private Node last;
    int N = 0;

    private class Node {
        Item item;
        Node next;
    }

    @Override
    public boolean isEmpty() {
        return N == 0;
    }

    @Override
    public int size() {
        return N;
    }

    @Override
    public MyQueue<Item> add(Item item) {

        Node newNode = new Node();
        newNode.item = item;
        newNode.next = null;

        if (isEmpty()) {
            last = newNode;
            first = newNode;
        } else {
            last.next = newNode;
            last = newNode;
        }

        N++;
        return this;
    }

    @Override
    public Item remove() throws Exception {

        if (isEmpty()) {
            throw new Exception("queue is empty");
        }

        Node node = first;
        first = first.next;
        N--;

        if (isEmpty()) {
            last = null;
        }

        return node.item;
    }

    @Override
    public Iterator<Item> iterator() {
        return new Iterator<Item>() {
        
            Node cur = first;

            @Override
            public boolean hasNext() {
                return cur != null;
            }

            @Override
            public Item next() {
                Item item = cur.item;
                cur = cur.next;
                return item;
            }
        };
    }
}
```











