栈和队列
----

用栈实现队列

232. Implement Queue using Stacks (Easy)

一个栈实现：

    class MyQueue {
        private Stack<Integer> st = new Stack();
    
        public void push(int x) {
            Stack<Integer> temp = new Stack();
            while (!st.isEmpty()) {
                temp.push(st.pop());
            }
            st.push(x);
            while (!temp.isEmpty()) {
                st.push(temp.pop());
            }
        }
    
        public int pop() {
            return st.pop();
        }
    
        public int peek() {
            return st.peek();
        }
    
        public boolean empty() {
            return st.isEmpty();
        }
    }

两个栈实现：

    class MyQueue {
    
        private Stack<Integer> in = new Stack();
        private Stack<Integer> out = new Stack();
    
        public void push(int x) {
            in.push(x);
        }
    
        public int pop() {
            in2out();
            return out.pop();
        }
    
        public int peek() {
            in2out();
            return out.peek();
        }
    
        private void in2out() {
            if (out.isEmpty()) {
                while (!in.isEmpty()) {
                    out.push(in.pop());
                }
            }
        }
    
        public boolean empty() {
            return in.isEmpty() && out.isEmpty();
        }
    }

用队列实现栈

225. Implement Stack using Queues (Easy)

    class MyStack {
    
        private Queue<Integer> queue;
    
        public MyStack() {
            queue = new LinkedList<>();
        }
    
        public void push(int x) {
            queue.add(x);
            int cnt = queue.size();
            while (cnt-- > 1) {
                queue.add(queue.poll());
            }
        }
    
        public int pop() {
            return queue.remove();
        }
    
        public int top() {
            return queue.peek();
        }
    
        public boolean empty() {
            return queue.isEmpty();
        }
    }

最小值栈

155. Min Stack (Easy)

用两个栈实现，一个存储数据，一个存储最小值。

    class MinStack {
    
        private Stack<Integer> dataStack;
        private Stack<Integer> minStack;
        private int min;
    
        public MinStack() {
            dataStack = new Stack<>();
            minStack = new Stack<>();
            min = Integer.MAX_VALUE;
        }
    
        public void push(int x) {
            dataStack.add(x);
            min = Math.min(min, x);
            minStack.add(min);
        }
    
        public void pop() {
            dataStack.pop();
            minStack.pop();
            min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();
        }
    
        public int top() {
            return dataStack.peek();
        }
    
        public int getMin() {
            return min;
        }
    }

对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。

用栈实现括号匹配

20. Valid Parentheses (Easy)

"()[]{}"

Output : true

    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[') stack.push(c);
            else {
                if (stack.isEmpty()) return false;
                char cStack = stack.pop();
                boolean b1 = c == ')' && cStack != '(';
                boolean b2 = c == ']' && cStack != '[';
                boolean b3 = c == '}' && cStack != '{';
                if (b1 || b2 || b3) return false;
            }
        }
        return stack.isEmpty();
    }

数组中元素与下一个比它大的元素之间的距离

Input: [73, 74, 75, 71, 69, 72, 76, 73]
Output: [1, 1, 4, 2, 1, 1, 0, 0]
739. Daily Temperatures (Medium)

在遍历数组时用 Stack 把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。

    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] ret = new int[n];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                int idx = stack.pop();
                ret[idx] = i - idx;
            }
            stack.add(i);
        }
        return ret;
    }

在另一个数组中比当前元素大的下一个元素

496. Next Greater Element I (Easy)

Input: nums1 = [4,1,2], nums2 = [1,3,4,2].
Output: [-1,3,-1]

    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer, Integer> map = new HashMap<>();
        Stack<Integer> stack = new Stack<>();
        for (int num : nums2) {
            while (!stack.isEmpty() && num > stack.peek()) {
                map.put(stack.pop(), num);
            }
            stack.add(num);
        }
        int[] ret = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            if (map.containsKey(nums1[i])) ret[i] = map.get(nums1[i]);
            else ret[i] = -1;
        }
        return ret;
    }

循环数组中比当前元素大的下一个元素

503. Next Greater Element II (Medium)

    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length, next[] = new int[n];
        Arrays.fill(next, -1);
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < n * 2; i++) {
            int num = nums[i % n];
            while (!stack.isEmpty() && nums[stack.peek()] < num)
                next[stack.pop()] = num;
            if (i < n) stack.push(i);
        }
        return next;
    }


tags:数据结构


